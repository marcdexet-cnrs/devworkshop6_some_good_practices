= Flexibility

//tag::include[]

[.subsection.background]
[.center]
[%notitle]
== Flexibility

[.big]#{chapter_name} - Part {counter:design_counter:1}#

[.huge]#Flexibility#

[NOTE.notes]
--
* Delimit the perimeter
* Tell What it does, don't think about how it's done.
* Engage for interface, not (yet) about implementation
* Keep the freedom of experimentating
* => interface
--


== Coupling

[.center]
image::images/marc/coupling.gif[]

[.center]
When any change to one component implies to modify the other one.


== Coupling

[.at-top-right]
image::images/marc/coupling.gif[width=200]

* When components are tightly coupled
** Evolving one can quickly become a nightmare.
** Side effects will be numerous and discouraging.

[.fragment]
--
For a few components, it doesn't really matter.
--

== Coupling

But with a lot of components, it would turn into a nightmare !

[.center]
image::images/marc/OpenBCoupling.gif[]

[.center]
== So how to decouple ?


[background-color="black", background-video="images/marc/isolated_base.mp4",background-video-loop=true,background-video-muted=true,background-size="contain"]
[%notitle]
== How to decouple ?

[NOTE.notes]
--
By putting a flexible layer !
--

== How to decouple ?

* In software engineering, coupling means
bound by *too much* knowledge.
* Decoupling => Limit required knowledge

* Three strategies
** Only take into account contract FIND A NEW NAME s
** Have the necessary and sufficient appearance FIND A NEW NAME
** inversion of dependencies


include::03_flexibility_01_abstraction.adoc[tag=include]

include::03_flexibility_02_segregation_of_interface.adoc[tag=include]

include::03_flexibility_03_inversion_of_dependency.adoc[tag=include]








//end::include[]
