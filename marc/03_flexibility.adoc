= Flexibility

//tag::include[]

[.subsection.background]
[.center]
[%notitle]
== Flexibility

[.big]#{chapter_name} - Part {counter:design_counter:1}#

[.huge]#Flexibility#

[NOTE.notes]
--
* Delimit the perimeter
* Tell What it does, don't think about how it's done.
* Engage for interface, not (yet) about implementation
* Keep the freedom of experimentating
* => interface
--


== Coupling

[.center]
image::images/marc/coupling.gif[]

[.center]
When any change to one component implies to modify the other one.

[.fragment]
[.center]
--
For a few components, it doesn't really matter.
--


== Coupling

But with a lot of components, it would turn into a nightmare !

[.center]
image::images/marc/OpenBCoupling.gif[]

[.center]
== So how to decouple ?


[background-color="black", background-video="images/marc/isolated_base.mp4",background-video-loop=true,background-video-muted=true,background-size="contain"]
[%notitle]
== How to decouple ?

[NOTE.notes]
--
By putting a flexible layer !
--

== How to decouple ?

* In software engineering, coupling means
bound by *too much* knowledge.

* 3 strategies to limit required knowledge
** Only take contract into account
** Show only what's is needed
** Inversion of dependencies


include::03_flexibility_01_abstraction.adoc[tag=include]

include::03_flexibility_02_segregation_of_interface.adoc[tag=include]

include::03_flexibility_03_inversion_of_dependency.adoc[tag=include]








//end::include[]
