= Flexibility

//tag::include[]

[.subsection.background]
[.center]
[%notitle]
== Flexibility

[.big]#{chapter_name} - Part {counter:design_counter:1}#

[.huge]#Flexibility#

== Flexibility

*A REFAIRE*

* Why do you need flexibility ?
** flexibility for change
** flexibility for evolution without breaking anything
** Don't break everything

* How to get flexibility
** Reduce Coupling
** Use contract

[NOTE.notes]
--
* Delimit the perimeter
* Tell What it does, don't think about how it's done.
* Engage for interface, not (yet) about implementation
* Keep the freedom of experimentating
* => interface
--


== Coupling

[.center]
image::images/marc/coupling.gif[]

[.center]
When any change to one component implies to modify the other one.


== Coupling

[.at-top-right]
image::images/marc/coupling.gif[width=200]

* When components are tightly coupled
** Evolving one can quickly become a nightmare.
** Side effects will be numerous and discouraging.

[.fragment]
--
For a few components, it doesn't really matter.
--

== Coupling

But with a lot of components, it would turn into a nightmare !

[.center]
image::images/marc/OpenBCoupling.gif[]


== How to decouple ?

[background-color="black", background-video="images/marc/isolated_base.mp4",background-video-loop=true,background-video-muted=true,background-size="contain"]
[%notitle]
== Foo

== How to decouple ?

*A REFAIRE*

In software, coupling means you're bound by too much knowledge.

* Limit required knowledge
** To be linked to the *WHAT* and not to the *HOW*.
** Use indirection
** Fire and Forget

The WHAT if the promise, the HOW is the implementation.





== Limit required knowledge

* Only take into account contracts
* Have the necessary and sufficient appearance


== Only take into account contract 0


[.left-column]
[.center]
--
image::images/marc/flexibility-bound2interface_0.svg[width=200]
--

[.right-column]
--
Imagine a context where +
a component of type *A* +
_uses_ a component of type *B*.

This is a dependency between *A* and *B*.
--

== Only take into account contract 1


[.left-column]
[.center]
--
image::images/marc/flexibility-bound2interface_1.svg[width=200]
--

[.right-column]
--
If *B* changes, *A* is certainly forced to _adapt_.
--


== Only take into account contract 1b


[.left-column]
[.center]
--
image::images/marc/flexibility-bound2interface_propagation_0.svg[]
--

[.fragment]
[.right-column]
[.center]
--
image::images/marc/flexibility-bound2interface_propagation_1.svg[]
--

== Only take into account contract 2


[.left-column]
[.center]
--
image::images/marc/flexibility-bound2interface_2.svg[width=200]
--

[.right-column]
--

The best solution is
that *A* is not related +
*to* what dependency [.huge]#is#, +
but *to* what it [.huge]#offers#.

[.fragment]
To use a kind of [.huge]#contract#.

[.fragment]
It describes [.huge]#WHAT# dependency does +
and doesn't care *HOW*.
--


== Only take into account contract 2



[.left-column]
--
* "Browser" contract
** _Fetch a content on internet given a valid URL_
** _Display content using HTML_
** _Submit valid HTTP form to a given URL_
** _Bookmark favorites_
** ...
--



[.fragment]
[.right-column]
[.center]
--
image::images/marc/browser_contract.gif[]
--

== Only take into account contract 3


[.left-column]
[.center]
--
image::images/marc/flexibility-bound2interface_3.svg[width=200]
--

[.right-column]
--
So as long as component _respect_ the contract, +
it could be anything.

We say dependency *implements* the contract.
--

== Only take into account contract 4


[.left-column]
[.center]
--
image::images/marc/flexibility-bound2interface_4.svg[width=200]
--

[.right-column]
--
A dependency can be modified, +
as long as it respects the contract, +
we don't care...
--

== Only take into account contract 5


[.left-column]
[.center]
--
image::images/marc/flexibility-bound2interface_5.svg[width=200]
--

[.right-column]
--
But if contract changes, +
both of them have to change.
--


== Only take into account contract 5


[.left-column]
[.center]
--
image::images/marc/flexibility-bound2interface_5bis.svg[width=200]
--

[.right-column]
--
From the *A* point of view, +
*only* _B contract_ exists.
--


== Only take into account contract 6


[.left-column]
[.center]
--
image::images/marc/flexibility-bound2interface_6.svg[width=400]
--

[.right-column]
--
Illustration with a Camera Operator _using_ a camera of Fony Inc.
--

== Only take into account contract 7


[.left-column]
[.center]
--
image::images/marc/flexibility-bound2interface_7.svg[width=400]
--

[.right-column]
--
If the camera is changed to a _very_ different model, +
Camera Operator has certainly to _be adapted_.

[.fragment]
And we know there's a lot of camera models on the market...
--

== Only take into account contract 8


[.left-column]
[.center]
--
image::images/marc/flexibility-bound2interface_8.svg[width=400]
--

[.right-column]
--
The better is to relate to a _camera contract_,
instead of a _camera model_.

Contrat => [.huge]#interface#.


--

== Only take into account contract 9


[.left-column]
[.center]
--
image::images/marc/flexibility-bound2interface_9.svg[width=400]
--

[.right-column]
--
So camera model could be changed, +
as long as it _implements_ the required *interface* +
we don't care.
--



== Only take into account contract 10


[.left-column]
[.center]
--
image::images/marc/flexibility-bound2interface_10.svg[width=400]
--

[.right-column]
--
And we could make easy our tests +
of Camera Operator +
without *hacking* a real camera.

[.fragment]
We just have to use a Mock Camera implementing _Camera Interface_.
--



== Conclusion of abstraction

*A REFAIRE*

* To gain flexibility
** Be linked to the contract, the interface, not the implementation.



[NOTE.notes]
--
* In real life
** If you have a very simple dependency, don't bother with interface.
** Use *interfaces*
*** when there's several implementations,
*** _or_ delicat, complexe, heavy dependencies,
*** _or_ depenceny is hard to mock in tests.
--


== Have The Necessary And Sufficient Appearance 0


[.left-column]
[.center]
--
image::images/marc/flexibility-segregation_0.svg[width=600]
--

[.center]
[.right-column]
--


Image you have now +
a TV _Reporting Camera Operator_ +
using a +
_Reporting Camera_ +
described by a +
_Reporting Camera Interface_.

[.fragment]
A _reporting camera_ is used +
for _reporting_ in the streets +


[.fragment]
It records +
_video_ +
and +
_sound_.
--


== Have The Necessary And Sufficient Appearance 0.1


[.left-column]
[.center]
--
image::images/marc/flexibility-segregation_0.1.svg[width=600]
--

[.right-column]
--
Someone decided to split +
_Reporting Camera Operator_ +
responsabilities +
in two parts.
--

== Have The Necessary And Sufficient Appearance 2


[.left-column]
[.center]
--
image::images/marc/flexibility-segregation_2.svg[width=600]
--

[.right-column]
--
They use the same interface.
--

== Have The Necessary And Sufficient Appearance 3


[.left-column]
[.center]
--
image::images/marc/flexibility-segregation_3.svg[width=600]
--

[.right-column]
--
But if the camera itself is separated into two components...

We get a nonsense.

A microphone that has to handle the video aspects is *stupid*.
--

== Have The Necessary And Sufficient Appearance 4


[.left-column]
[.center]
--
image::images/marc/flexibility-segregation_4.svg[width=600]
--

[.right-column]
[.center]
--
We have to limit each of them +
to *WHAT* they do +
and *only* what they do.

*No more and no less.*
--



== Have The Necessary And Sufficient Appearance 5


[.left-column]
[.center]
--
image::images/marc/flexibility-segregation_5.svg[width=600]
--

[.right-column]
[.center]
--
This way, any depency +
satisfying the interface +
could be used.
--

== Have The Necessary And Sufficient Appearance 6


[.left-column]
[.center]
--
image::images/marc/flexibility-segregation_6.svg[width=600]
--

[.right-column]
[.center]
--
This way, any depency +
satisfying the interface +
could be used.
--


== Have The Necessary And Sufficient Appearance 6.1


[.left-column]
[.center]
--
image::images/marc/flexibility-segregation_6.1.svg[width=600]
--

[.right-column]
--
What about our _Reporting Camera Operator_ ? +

It could use the both interfaces.

Whether it's implemented by _two_ components...
--


== Have The Necessary And Sufficient Appearance 6.2


[.left-column]
[.center]
--
image::images/marc/flexibility-segregation_6.2.svg[width=600]
--

[.right-column]
--
\... or implemented by _only one_ component !

We don't care.
--





== Have The Necessary And Sufficient Appearance 7


[.left-column]
[.center]
--
image::images/marc/flexibility-segregation_7.svg[width=600]
--

[.right-column]
[.center]
--
But if you're in a field +
limited to TV Reporting only, +
you would prefer talking about _Reporting camera_.

How to reconcile the two universes ?

By making _Reporting camera_ +
be a _Camera interface_ +
*and* +
a _Microphone interface_ too.
--

== Have The Necessary And Sufficient Appearance 8


[.left-column]
[.center]
--
image::images/marc/flexibility-segregation_8.svg[width=600]
--

[.right-column]
--
So you have a very flexible architecture like this...
--

== Have The Necessary And Sufficient Appearance 9


[.left-column]
[.center]
--
image::images/marc/flexibility-segregation_9.svg[width=600]
--

[.right-column]
--
\... or this with a delegation to the microphone for all the _Microphone stuff_.
--


== Have The Necessary And Sufficient Appearance 6.before.2


[.left-column]
[.center]
--
image::images/marc/flexibility-segregation_6.before.2.svg[width=600]
--

[.right-column]
[.center]
--
We split a too general interface into +
two very user _focused_ interfaces.

[.fragment]
It called +
[.huge]#Segregation of Interfaces#.
--

== Have The Necessary And Sufficient Appearance 6.3


[.center]
--
image::images/marc/flexibility-segregation_6.3.svg[width=600]

So the general _Reporting Camera Interface_ +
could be seen as a +
_video interface_ for video interested users.
--


[transition=fade]
== Have The Necessary And Sufficient Appearance 6.4


[.center]
--
image::images/marc/flexibility-segregation_6.4.svg[width=600]


\...or a
_Microphone interface_ for sound interested users.
--


== Have The Necessary And Sufficient Appearance 10


[.left-column]
[.center]
--
image::images/marc/flexibility-segregation_10.svg[width=600]
--

[.right-column]
[.center]
--
*Segregation Of Interfaces* allows +
to join different universes +
with different point of view.

Here the _TV universe_ +
and +
the camera _Manufacturer Universe_.
--

== Put a abstraction layer between component

*A REFAIRE*

A interface is door fire-cut.



//end::include[]
