= Conception


Il faut rappeller que ces principes à tous les niveaux
- Conception générale
- Design
- Codage

A l'echelle d'un pipeline, d'un module, d'une classe, d'une simple fonction.

Ce sont des lignes de conduites

//tag::include[]


{counter2:design_counter}


[.subsection.background]
[.center]
[%notitle]
== Dealing With Complexity

[.big]#Part {design_counter}# +
[.huge]#Dealing With Complexity#


== Dealing With Complexity


[.fragment]
--
* Complex vs Complicated ?
** _Complex_ as opposed to _simple_ => _indirect_,
** _Complicated_ as opposed to _easy_ => _difficult_.
--

[.fragment]
--
If _complexity_ is not a problem, _complication_ should be avoided.
--

[.fragment]
--
* Abstraction, Complixity, Complication
** The more _abstract_ are ideas, the more _complex_ is implementation.
** The more _complex_ is implementation, the more _complicated_ *may be* the code
--

[.fragment]
[.center]
--
[big]#Complexity#  => [.big]#Complicated#


In general, _complexity_ leads to _complication_ if you are not careful.
--

[.fragment]
--
So be careful...
--

[NOTE.notes]
--
There is always some confusion between Complex and Complicated.
Complex can be opposed to simple while complicated can be opposed to easy.
Software can be complex, because the implementation of the underlying ideas requires several steps or depths.

But such architecture is not complicated, it is just not direct.

On the contrary, a simple idea could be complicated to implement as software, could be very tricky and difficult to write, to understand.

In general, complexity leads to complication if you are not careful.


Exemple with networks
https://www.itrw.net/2016/06/27/organized-cabling-is-better-cabling-avoid-server-room-spaghetti/

--

include::03_part_what_and_how.adoc[tag=include]


== Dealing With Complexity

* Reduce the number of elements to take into account
* Distinguish different levels of abstraction
* Isolate and decouple elements


== Reduce the number of elements to take into account

If there's a few elements, it doesn't really matter.

[.center]
image::images/marc/good_practices-reduce_complexity_0.svg[]


[NOTE.notes]
--
In the turning idea to code, there's could be a lot of steps to follow to achieve the goals.
If there's a few elements, it doesn't really matter.

--

[transition=none]
== Reduce the number of elements to take into account

But with some more...

[.center]
image::images/marc/good_practices-reduce_complexity_1.svg[]

[transition=none]
== Reduce the number of elements to take into account

Imagine each element could be linked to a concern...

[.center]
image::images/marc/good_practices-reduce_complexity_2.svg[]

== Concern ?

A concern is a subject of interest, a goal

[.left-column]
--
* For a restaurant
** Kitchen
** Cooking 
** Orders
** Payments
** Stock
** Service
** ...
--

[.right-column]
--
* For a car
** Engine
** Fuel
** GearBox
** Frame
** ..
--

[.reset-column]
--
Try to connect each element to a concern !
--

== Group by concern

[.center]
image::images/marc/good_practices-reduce_complexity_2.svg[]

[transition=none]
== Group by concern

[.center]
image::images/marc/good_practices-reduce_complexity_3.svg[]

[transition=none]
== Group by concern

[.center]
image::images/marc/good_practices-reduce_complexity_4.svg[]

[transition=none]
== Group by concern

[.center]
image::images/marc/good_practices-reduce_complexity_6.svg[]


== Separation of concern

[.center]
image::images/marc/good_practices-reduce_complexity_6.svg[width=400]

This is, roughly speaking, the principle of good practice *Separation of Concern*.


You didn't magically remove _all_ the complexity.

[.fragment]
But, you have reduced _cognitively_ the number of elements ... 

[.fragment]
\... per *level of abstraction*


== Separation of concern

Grouping element by concern could be a question of point of view.


* Choose concepts such as 
** they have the more limited intersection,
** they are the more consistent, 
*** _Cooking and Astronomy_ is not very consistent !
** they are atomic and focused

[.fragment]
* In programming world :
** module
** package
** namespace
** classe


== Separate level of abstaction

[.center]
image::images/marc/good_practices-level_complexity_2_0.svg[]


[transition=none]
== Separate level of abstaction

[.center]
image::images/marc/good_practices-level_complexity_2_1.svg[]


[transition=none]
== Separate level of abstaction

[.center]
image::images/marc/good_practices-level_complexity_2_2.svg[]

[transition=none]
== Separate level of abstaction

[.center]
image::images/marc/good_practices-level_complexity_2_3.svg[]


== Breakdown Big Problem

[NOTE.notes]
--
* Your brain is not well built to maintain heavy concepts and many irritating details.
* Break problem down to little problems
* => conception
--



== You want to shoot a video

* You are on holiday,
** You see a nice landscape, you take a video with your smartphone
** _shoot_the_movie()_

* You are on holiday with some friend
** You want to send a happy birthday song video to another friend
** _manage_friends()_
** _prepare_song()_
** _shoot_movie()_
** _send_movie()_

* Vous préparer une vidéo de vulgarisation sur la matière noire pour Youtube
** preparer le script
** choisir le décor
** choisir les interlocuteurs
** choisir les props
** choisir..
** ...
** monter sur youtube

* You want to shoot a feature film with actors, sets and a story

[NOTE.notes]
--
prendre une série de cas où je peux mélanger complexité et niveau d'abstraction
--


== Flexibility

[NOTE.notes]
--
* Delimit the perimeter
* Tell What it does, don't think about how it's done.
* Engage for interface, not (yet) about implementation
* Keep the freedom of experimentating
* => interface
--




== Separation Of Concern


== Single Responsability


== Segregation of interface


[source,python]
----
class FilmDirector :
...
	def say_action(self, john: John):
		if john.say_set_is_ready():
			do_something()
		if john.say_lighting_is_ok():
			do_something_else()

----

But John is tired and is remplaced by Barabara who give lightnig direction to Tuong



[source,python]
----
class FilmDirector :
...
	def say_action(self, barabara: Barabara):
		if barabara.say_set_is_ready():
			do_something()
		if barabara.say_lighting_is_ok(): # Oooops
			do_something_else()

----



[source,python]
----
class FilmDirector :
...
	def say_action(self, barabara: Barabara, tuong: Tuong):
		if barabara.say_set_is_ready():
			do_something()
		if tuong.say_lighting_is_ok():
			do_something_else()

----


FilmDirector is coupled to implementation.

it's bad

What itreally need is specific responsability centric abstraction

[source,python]
----
class FilmDirector :
...
	def say_action(self, set_director: SetDirector, lighting_director: LightingDirector):
		if set_director.say_set_is_ready():
			do_something()
		if lighting_director.say_lighting_is_ok():
			do_something_else()

----



[NOTE.notes]
--
Imagine that John is the Set Director and the Lighting Director.
The Film Director is thigly coupled to knwoledge of what John does.
--


//end::include[]
