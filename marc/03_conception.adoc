= Conception


Il faut rappeller que ces principes à tous les niveaux
- Conception générale
- Design
- Codage

A l'echelle d'un pipeline, d'un module, d'une classe, d'une simple fonction.

Ce sont des lignes de conduites

//tag::include[]


{counter2:design_counter}


[.subsection.background]
[.center]
[%notitle]
== Dealing With Complexity

[.big]#Part {design_counter}# +
[.huge]#Dealing With Complexity#


== Dealing With Complexity


[.fragment]
--
* Complex vs Complicated ?
** _Complex_ as opposed to _simple_ => _indirect_,
** _Complicated_ as opposed to _easy_ => _difficult_.
--

[.fragment]
--
If _complexity_ is not a problem, _complication_ should be avoided.
--

[.fragment]
--
* Abstraction, Complixity, Complication
** The more _abstract_ are ideas, the more _complex_ is implementation.
** The more _complex_ is implementation, the more _complicated_ *may be* the code
--

[.fragment]
[.center]
--
[big]#Complexity#  => [.big]#Complicated#


In general, _complexity_ leads to _complication_ if you are not careful.
--

[.fragment]
--
So be careful...
--

[NOTE.notes]
--
There is always some confusion between Complex and Complicated.
Complex can be opposed to simple while complicated can be opposed to easy.
Software can be complex, because the implementation of the underlying ideas requires several steps or depths.

But such architecture is not complicated, it is just not direct.

On the contrary, a simple idea could be complicated to implement as software, could be very tricky and difficult to write, to understand.

In general, complexity leads to complication if you are not careful.


Exemple with networks
https://www.itrw.net/2016/06/27/organized-cabling-is-better-cabling-avoid-server-room-spaghetti/

--


== Dealing With Complexity

* Reduce the number of elements to take into account
* Distinguish different levels of abstraction
* Isolate and decouple elements


== Reduce the number of elements to take into account

If there's a few elements, it doesn't really matter.

[.center]
image::images/marc/good_practices-reduce_complexity_0.svg[]


[NOTE.notes]
--
In the turning idea to code, there's could be a lot of steps to follow to achieve the goals.
If there's a few elements, it doesn't really matter.

--

[transition=none]
== Reduce the number of elements to take into account

But with some more...

[.center]
image::images/marc/good_practices-reduce_complexity_1.svg[]

[transition=none]
== Reduce the number of elements to take into account

Imagine each element could be linked to a concern...

[.center]
image::images/marc/good_practices-reduce_complexity_2.svg[]

== Concern ?

A concern is a subject of interest, a goal

[.left-column]
--
* For a restaurant
** Kitchen
** Cooking
** Orders
** Payments
** Stock
** Service
** ...
--

[.right-column]
--
* For a car
** Engine
** Fuel
** GearBox
** Frame
** ..
--

[.reset-column]
--
Try to connect each element to a concern !
--

== Group by concern

[.center]
image::images/marc/good_practices-reduce_complexity_2.svg[]

[transition=none]
== Group by concern

[.center]
image::images/marc/good_practices-reduce_complexity_3.svg[]

[transition=none]
== Group by concern

[.center]
image::images/marc/good_practices-reduce_complexity_4.svg[]

[transition=none]
== Group by concern

[.center]
image::images/marc/good_practices-reduce_complexity_6.svg[]


== Separation of concern

[.center]
image::images/marc/good_practices-reduce_complexity_6.svg[width=400]

This is, roughly speaking, the principle of good practice *Separation of Concern*.


You didn't magically remove _all_ the complexity.

[.fragment]
But, you have reduced _cognitively_ the number of elements ...

[.fragment]
\... per *level of abstraction*


== Separation of concern

Grouping element by concern could be a question of point of view.


* Choose contents such as
** they have limited _intersection_,
*** _but intersection will occur._
** they are consistent and focused,
*** _Cooking and Astronomy_ is not very consistent !

[.fragment]
* In programming world :
** module
** package
** namespace
** classe


== Separate levels of abstraction

[.center]
image::images/marc/good_practices-level_complexity_2_0.svg[width=600]


[transition=none]
== Separate levels of abstraction

[.left-column]
[.center]
image::images/marc/good_practices-level_complexity_2_1.svg[width=600]

[.right-column]
--
* Several layers of abstraction,
** From the general concepts to the specialized components.
--

[transition=none]
== Separate levels of abstraction

[.left-column]
[.center]
image::images/marc/good_practices-level_complexity_2_1_bis.svg[width=600]


--
* On each layer we found the elements
** by level  of abstraction.
--

[transition=none]
== Separate levels of abstraction

[.left-column]
[.center]
image::images/marc/good_practices-level_complexity_2_2.svg[width=600]


[.right-column]
--
* Each level could be separated by sub-concern
--

[transition=none]
== Separate levels of abstraction

[.left-column]
[.center]
image::images/marc/good_practices-level_complexity_2_3.svg[width=600]


[.right-column]
--
* Element could interact
** Inside a concern
*** At the same level
*** From level to another one
** Between concerns
--

[transition=none]
== Separate levels of abstraction

[.left-column]
[.center]
image::images/marc/good_practices-level_complexity_2_4.svg[width=600]

[.right-column]
--
* But one of the best way of doing
** is to interact through the top levels
--


[transition=none]
== Separate levels of abstraction

[.left-column]
[.center]
image::images/marc/good_practices-level_complexity_blackboxes.svg[width=600]

[.right-column]
--
* Such as black boxes
** whose contents can be more freely modified.
* It provides more *isolation*
--


include::03_illustration_with_movie_industry.adoc[tag=include]

include::03_part_what_and_how.adoc[tag=include]


== Flexibility

[NOTE.notes]
--
* Delimit the perimeter
* Tell What it does, don't think about how it's done.
* Engage for interface, not (yet) about implementation
* Keep the freedom of experimentating
* => interface
--


== Coupling

[.center]
image::images/marc/coupling.gif[]

[.center]
When any change to one component implies to modify the other one.


== Coupling

[.at-top-right]
image::images/marc/coupling.gif[width=200]

* When components are tightly coupled
** Evolving one can quickly become a nightmare.
** Side effects will be numerous and discouraging.

[.fragment]
--
For a few components, it doesn't really matter.
--

== Coupling

But for a lot of components, it would turn into a nightmare !

[.center]
image::images/marc/OpenBCoupling.gif[]



== How to decouple

* Put a abstraction layer bet

== Breakdown Big Problem

[NOTE.notes]
--
* Your brain is not well built to maintain heavy concepts and many irritating details.
* Break problem down to little problems
* => conception
--





== Separation Of Concern


== Single Responsability


== Segregation of interface


[source,python]
----
class FilmDirector :
...
	def say_action(self, john: John):
		if john.say_set_is_ready():
			do_something()
		if john.say_lighting_is_ok():
			do_something_else()

----

But John is tired and is remplaced by Barabara who give lightnig direction to Tuong



[source,python]
----
class FilmDirector :
...
	def say_action(self, barabara: Barabara):
		if barabara.say_set_is_ready():
			do_something()
		if barabara.say_lighting_is_ok(): # Oooops
			do_something_else()

----



[source,python]
----
class FilmDirector :
...
	def say_action(self, barabara: Barabara, tuong: Tuong):
		if barabara.say_set_is_ready():
			do_something()
		if tuong.say_lighting_is_ok():
			do_something_else()

----


FilmDirector is coupled to implementation.

it's bad

What itreally need is specific responsability centric abstraction

[source,python]
----
class FilmDirector :
...
	def say_action(self, set_director: SetDirector, lighting_director: LightingDirector):
		if set_director.say_set_is_ready():
			do_something()
		if lighting_director.say_lighting_is_ok():
			do_something_else()

----



[NOTE.notes]
--
Imagine that John is the Set Director and the Lighting Director.
The Film Director is thigly coupled to knwoledge of what John does.
--


//end::include[]
