= Intro

L'introduction sert à planter le décors.

Pourquoi créons nous des logiciels au fond ?

* Pour mettre des idées en action (pour concrétiser), idées que nous ne trouvons pas pertinent de faire nous mêmes pour de multiples raisons
** performance
** répétitivité
** coût
** priorité

Ensuite pourquoi c'est difficile en soi ?
Au niveau de la réalisation en soi, en supposant que les solutions envisagées répondent déjà au besoin, du moins sur le papier

Problème de traduction, passage du code à l'idée et vice-versa (zoom)
* Problème de traduction de l'idée au code
* Problème de compréhension du code
* Gestion de la complexité

Ensuite il y a la notion de partage
* Partage au sens de plusieurs personnes sur le même logiciel
* Partage en tant que fourrnisseur de service avec d'autres logiciels
* Partage dans le temps: l'expertise d'aujourd'hui est l'oubli de demain

Ensuite il y a l'évolution
* Evolution continue du code
** Un code ne doit pas être fait que pour fonctionner, il doit être fait pour évoluer !!
** Un logiciel est vivant => un logiciel figé est un logiciel mort
** Parallèle avec le darwinisme => un logiciel qui ne sait pas s'adapter facilement est un logiciel appelé à s'éteindre très vite

La gestion d'un univers qui a ses propres règles et propres défaillances

* A creuser


*Il faut néanmoins faire court, 4 à 5 slides maximum !!*

//tag::include[]

[.subsection.background]
[.center]
== Why ?

[.fragment]
Why Are We
Building Software ?

[.fragment]
By The Way ?

== Why Are We Building Software ?


*A REFAIRE*

[.fragment]
--
* Because it's a very powerful tool
** To do stupid or boring or endless stuff,
** To implement ideas,
** To achieve objectives,
** To satisfy needs,
** To apply a vision of the world,
** ...
--


[.fragment]
--
* We make software to put ideas into action.
** We try to put our ideas into code to hope see them into action :)
--


[NOTE.notes]
--
* Software are just tool for a lot of you.
* Tool -> to achieve objectives, goals.
* There is a link between a idea, a need and a software.
--

== Why It Could Be Tricky To Build Software ?

*A REFAIRE*

* Translation -> scaling
* Complexity -> breaking up
* Evolution -> Changeability

[.center]
[%notitle]
[background-color="#04011e"]
== Lost In Translation

image::images/marc/matt_taylor_lost_in_translation_var-600x800.jpg[width=500]

[.center]
[%notitle]
[background-color="#1e0115"]
=== Lost In Translation

image::images/marc/matt_taylor_lost_in_translation_reg.jpg[]


=== Lost In Translation

[.fragment]
--
* Translate *ideas* into *code*
** As the Italian say "Traduttore, traditore" -> _Translator, traitor_
--

[.fragment]
--
* Translation Implies Distorsion
** The further _away_ from the code, the _greater_ the distortion.
** To _convert_ and _adapt_ into code => To _modify_ or _lost_ the meaning of our original ideas
--

[.fragment]
[.big]
[.center]
We could get lost in *complexity*.


[NOTE.notes]
--
Software is a tool to put ideas into action. But we have to convert our ideas into code to make them concrete. We have to translate a intellectual building into an computing piece of code, but translation is a kind of betrayal : "Traduttore, traditore".
We imply distorsion of our original ideas.
--

[.dark.background]
[.center]
=== Lost In Complexity

image::images/marc/blogs-images.forbes.com_ronashkenas_files_2014_06_7670055210_ceb0c9ef9a_b.jpg[width=800]


=== Lost In Complexity

[.fragment]
--
* Complex vs Complicated
** _Complex_ as opposed to _simple_ => _indirect_,
** _Complicated_ as opposed to _easy_ => _difficult_.
--

[.fragment]
--
If _complexity_ is not a problem, _complication_ should be avoided.
--

[.fragment]
--
* Abstraction, Complixity, Complication
** The more _abstract_ are ideas, the more _complex_ is implementation.
** The more _complex_ is implementation, the more _complicated_ *may be* the code
--

[.fragment]
--
In general, _complexity_ leads to _complication_ if you are not careful.
--

[.fragment]
--
So be careful...
--

[NOTE.notes]
--
There is always some confusion between Complex and Complicated.
Complex can be opposed to simple while complicated can be opposed to easy.
Software can be complex, because the implementation of the underlying ideas requires several steps or depths.
But such architecture is not complicated, it is just not direct.
On the contrary, a simple idea could be complicated to implement as software, could be very tricky and difficult to write, to understand.

In general, complexity leads to complication if you are not careful.


Exemple with networks
https://www.itrw.net/2016/06/27/organized-cabling-is-better-cabling-avoid-server-room-spaghetti/

--

=== Lost In Evolution

* Software is *ever* in *evolution*
** It is not written in one and unique time, and that's all !
* As _experience_ and _ideas_ evolve, software has to follow,
** So it have to be changeable.

[.fragment]
--
* A software that can not evolve is a fragile one.
--

[.fragment]
--
* => Be careful to make your code changeable...
--


[NOTE.notes]
--
* Software is an investissment
** Software is ever in evolution, it is not written  in one and unique time, it still evolving, like a very strange kind of animal, adapting to new needs or ideas, and like in darwin evolution, still  keeping some odd and old features, artefacts or piece of useless codes.
**  So make it running is not enough.

*Mettre une photo de panda.*
--


=== Sharing is caring

Un passage sur le fait que les logiciels ne sont pas des objets isolés, mais partagés

* Partagé car développé à plusieurs
* Partagé car utilisé par d'autres acteurs
* Partagé dans le temps


[NOTE.notes]
--
* Software is a kind of intellectual construction
** Software is a piece of distributed knowledge all over files, processes and so on
--

== What Are The Good Practices ?

[NOTE.notes]
--
* People have been building software for 40 years.
* People gather a pretty big set of principles, recipes, experiences built by severals years of try and fail.
* Unless you're a genius, it's worth it to start using them before creating your own path.
--

//end::include[]
